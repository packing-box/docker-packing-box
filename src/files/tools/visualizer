#!/usr/bin/python3
# -*- coding: UTF-8 -*-
from pbox import *
from tinyscript import *


__version__     = "2.0.3"
__contributors__ = [
    {'author': "Romain Jennes", 'reason': "added visualizations for observing effects of alterations"},
]
__doc__         = """
This tool aims to generate representations of binaries, emphasizing their sections and plotting their entropy,
 for the sake of comparing them, e.g. an original PE file and its packed versions.
"""
__description__ = "Generate a figure with representations of input binaries' sections and entropy"
__examples__    = [
    "compare \"PsExec.exe$\" samples-folder \"PsExec.exe$\" altered-samples-folder",
    "features \".$\" dataset-packed-pe --label Exe32Pack",
    "find \".$\" dataset-packed-pe --max-not-matching 2",
    "plot \"PsExec.exe$\" PackingData -l not-packed -l MEW -l NSPack -l RLPack -l UPX",
]


LABELS = {
    'not-packed':         "Original",
    'Notpacked':          "Original",
    'BeRoEXEPacker':      "BeRo",
    'Enigma Virtual Box': "Enigma VBox",
    'Eronana Packer':     "Eronana",
}


def legend_location(string):
    ver, hor = string.split("-", 1)
    if ver not in ["lower", "center", "upper"] or hor not in ["left", "center", "right"]:
        raise ValueError(string)
    return string.replace("-", " ")
legend_location.__name__ = "legend location"


def find_files(folder, pattern, selected=None, nbr_not_selected=None, display=False, force_display=False, remove=False,
               filter_selected=True):
    """ Find files matching the given filename pattern withing the specified folder. It uses subfolders' names as labels
         for categorizing the matching file.
    
    For instance:
        FOLDER
          +-- not-packed
          +-- packed
                +-- ASPack
                +-- UPX
                +-- WinUPack
        
        if a file matches in every subfolder, we will have (filename => label):
            [filename-from-not-packed] => Original
            [filename-from-packed/ASPack] => ASPack
            [...]
    
    :param folder:   source folder
    :param pattern:  pattern for matching files
    :param selected: list of labels to be filtered (keeps the order)
    """
    preffixes, available_labels, files, disp_all = {}, [], {}, selected is None
    # collect (best matching) preffixes first
    for dp in ts.Path(folder).walk(filter_func=lambda x: x.is_dir()):
        # discard .git/* and non-leaf subfolders of the folder tree structure
        if ".git" in dp.parts or len(list(dp.listdir(filter_func=lambda x: x.is_dir()))) > 0:
            continue
        l, prev, preffix = dp.basename, None, {}
        for f in dp.listdir(filter_func=lambda x: x.is_file()):
            common = ""
            for c1, c2 in zip(prev or f.stem, f.stem):
                if c1 == c2:
                    common += c1
                else:
                    break
            preffix.setdefault(common, 0)
            preffix[common] += 1
            prev = f.stem
        if len(preffix) > 0:
            preffixes[l] = max(preffix, key=preffix.get)
    # check for label errors
    error = False
    if selected is not None:
        for l in selected[:]:
            if l not in preffixes.keys():
                for good in preffixes.keys():
                    if good.lower() == l.lower():
                        logger.debug("Fixed label %s to %s" % (l, good))
                        selected[selected.index(l)] = good
                        l = None
                        break
                if l is not None:
                    logger.error("Bad label: %s" % l)
                    error = True
    if error:
        sys.exit(1)
    # collect matching files
    for fp in ts.Path(folder).walk(filter_func=lambda x: x.is_file()):
        # discard files from .git/* and non-leaf subfolders of the folder tree structure
        if ".git" in fp.parts or len(list(fp.dirname.listdir(filter_func=lambda d: d.is_dir()))) > 0:
            continue
        l = fp.dirname.basename
        if l not in available_labels:
            available_labels.append(l)
        if re.search(pattern, fp.filename):
            fname = fp.filename[len(preffixes[l]):]
            files.setdefault(fname, {'files': [], 'labels': []})
            files[fname]['labels'].append(l)
            files[fname]['files'].append(fp)
    if selected is None:
        selected = sorted(available_labels)
    len_al = len(available_labels)
    # discard files that have too few positive labels or that do not have the selected labels in their packed versions
    n, disp = 0, display or force_display
    for file, data in files.items():
        # set booleans for files having their label match one of the selected labels
        labels = {}
        for label in sorted(available_labels):
            try:
                data['files'][data['labels'].index(label)]
                labels[label] = True
            except ValueError:
                labels[label] = False
        # discard files for which either there is a non matching label in the selected ones or too few positive labels
        n_good = sum(labels.values())
        if not disp_all and any(not labels[l] for l in selected) or \
           nbr_not_selected is not None and n_good + nbr_not_selected < len_al:
            continue
        # display valid results
        if disp:
            file += " (%d/%d)" % (n_good, len_al)
        (logger.info if disp else logger.debug)(file)
        for label, found in labels.items():
            l = LABELS.get(label, label)
            if display:
                (logger.success if found else logger.failure)(l)
        n += 1
    if filter_selected:
        nfiles = {}
        for file, data in files.items():
            if remove:
                logger.info(file)
            ndata = {'files': [], 'labels': []}
            for label in selected:
                try:
                    ndata['files'].append(data['files'][data['labels'].index(label)])
                    ndata['labels'].append(label)
                except ValueError:
                    logger.warning("label '%s' not found" % label)
            nfiles[file] = ndata
        files = nfiles
    if n == 0:
        logger.warning("No match")
    return files


if __name__ == "__main__":
    sparsers = parser.add_subparsers(dest="command", metavar="CMD", title="positional argument",
                                     help="command to be executed")
    compare = add_argument(sparsers.add_parser("compare", help="compare files from two sources"), "folder", fmt=True,
                           extended=True)
    compare.add_argument("filename2", help="second binary to be represented ; format is regex")
    compare.add_argument("folder2", type=ts.folder_exists, help="second target folder")
    compare.add_argument("-l1", "--legend1", help="specify a string to show with the first binary")
    compare.add_argument("-l2", "--legend2", help="specify a string to show with the second binary")
    compare.add_argument("-o", "--out-file", metavar="FILE",
                         help="output file (for images, format is determined based on the extension)")
    compare.add_argument("-t", "--title", help="set plot title")
    compare.add_argument("--no-title", action="store_true", help="do not generate a main title")
    compare.add_argument("--text", action="store_true", help="textual comparison")
    feat = add_argument(sparsers.add_parser("features", help="compute features for files matching the regex with the "
                                                             "input labels"), "folder")
    feat.add_argument("-r", "--raw", action="store_true", help="display raw features only (not transformed ones)")
    find = add_argument(sparsers.add_parser("find", help="find files matching the regex with the input labels"),
                        "folder")
    find.add_argument("-d", "--no-display", action="store_false", help="do not display packer label matches")
    plot = add_argument(sparsers.add_parser("plot", help="plot files matching the regex given the selected labels"),
                        "folder", alias=True, fmt=True)
    plot.add_argument("--legend-location", default="lower-center", type=legend_location,
                      help="hyphen-separated pair of locators for the plot's legend")
    plot.add_argument("-n", "--no-title", action="store_true", help="do not generate a title")
    plot.add_argument("-s", "--scale", action="store_true", help="scale plots according to the first binary")
    rm = add_argument(sparsers.add_parser("remove", help="remove files matching the regex with the input labels"),
                      "folder")
    initialize(noargs_action="usage", autocomplete=True)
    ff_args = args.folder, args.filename, args.label, getattr(args, "max_not_matching", None)
    logger.name = "visualizer"
    logging.configLogger(logger, ["INFO", "DEBUG"][args.verbose], fmt=LOG_FORMATS[args.verbose], relative=True)
    LABELS.update(getattr(args, "alias", None) or {})
    msg = " files from %s matching '%s'%s..." % (args.folder, args.filename,
                                                 [" with the selected labels", ""][args.label is None])
    if args.command == "features":
        logger.info("Computing features of" + msg)
        for file, data in find_files(*ff_args).items():
            logger.info(file)
            files = []
            for f, l in zip(data['files'], data['labels']):
                exe = Executable(f)
                row = {'path': str(f), 'label': LABELS.get(l, l)}
                row.update(exe.rawdata if args.raw else exe.data)
                files.append(row)
            with data_to_temp_file(pd.DataFrame(files), prefix="visualizer-features-") as tmp:
                edit_file(tmp, logger=logger)
    elif args.command == "find":
        logger.info("Searching for" + msg)
        for _ in find_files(*ff_args, display=args.no_display, force_display=True, filter_selected=False).keys():
            pass
    elif args.command == "plot":
        from bintropy import plot
        logger.info("Collecting" + msg)
        for file, data in find_files(*ff_args).items():
            files, labels = data['files'], data['labels']
            labels = [LABELS.get(l, l) for l in labels]
            imgn = ts.Path(file).stem
            logger.info("Making plot to %s.%s..." % (imgn, args.format))
            for f in files:
                logger.debug(f)
            plot(*files, img_name=imgn, labels=labels, sublabel="size-ep-ent", logger=logger, **vars(args))
    elif args.command == "compare":
        msg2 = " files from %s matching '%s'%s..." % (args.folder2, args.filename2,
                                                 [" with the selected labels", ""][args.label is None])
        logger.info("Comparing" + msg + " to" + msg2)
        ff2_args = (args.folder2, args.filename2, args.label)
        for f1, f2  in zip(find_files(*ff_args).items(), find_files(*ff2_args).items()):
            data1, data2 = f1[1], f2[1]
            if args.text:
                print(binary_diff_readable(*data1['files'], *data2['files'], logger=logger, **vars(args)))    
            else:
                imgn = ts.Path(*data1['files']).stem + '_' + ts.Path(*data2['files']).stem if args.out_file is None \
                       else args.out_file
                logger.info("Making plot to %s..." % (imgn))
                binary_diff_plot(data1['files'][0], data2['files'][0], img_name=imgn, logger=logger, **vars(args))
    elif args.command == "remove":
        logger.info("Removing" + msg)
        for file, data in find_files(*ff_args, remove=True).items():
            if ts.confirm("Remove '%s' ?" % file):
                for f in data['files']:
                    f.remove()

